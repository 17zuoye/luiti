{"name":"Luiti","tagline":"luiti = luigi + time.","body":"Luiti\r\n========================\r\n[![Build Status](https://img.shields.io/travis/17zuoye/luiti/master.svg?style=flat)](https://travis-ci.org/17zuoye/luiti)\r\n[![Coverage Status](https://coveralls.io/repos/17zuoye/luiti/badge.svg)](https://coveralls.io/r/17zuoye/luiti)\r\n[![Health](https://landscape.io/github/17zuoye/luiti/master/landscape.svg?style=flat)](https://landscape.io/github/17zuoye/luiti/master)\r\n[![Download](https://img.shields.io/pypi/dm/luiti.svg?style=flat)](https://pypi.python.org/pypi/luiti)\r\n[![License](https://img.shields.io/pypi/l/luiti.svg?style=flat)](https://pypi.python.org/pypi/luiti)\r\n[![Python Versions](https://pypip.in/py_versions/luiti/badge.svg?style=flat)](https://pypi.python.org/pypi/luiti)\r\n\r\nLuigi 是一套基于 Python 语言构建的复杂流式批处理任务管理系统。它也仅仅是一个任务\r\n调度系统，具体逻辑全都由 Task 自己去实现，比如分布式计算交由 Hadoop 里的 YARN 实现处理。\r\n\r\nLuiti 是构建于 Luigi 之上的主要作用于时间管理相关的插件, 即\r\n Luiti = Luigi + time。\r\n\r\n\r\nluiti 优势\r\n------------------------\r\n1. 按时间和业务类型等属性去多目录划分基础表, 中间表, 统计表 等。[#](#core-concepts-based-on-time-management)\r\n2. 支持无缝 多项目 多版本 管理, 兼容常规 Python 库引用机制。[#](#manage-multiple-projects-in-luiti)\r\n3. 任务的运行时间和业务时间的满足条件检查。[#](#task-decorators)\r\n4. 众多 MapReduce / IO 实用操作函数。[#](#mapreduce-related)\r\n5. 基于输入输出数据的 MapReduce 测试方案。[#](#mr-test)\r\n6. 内置支持 Task 基类扩展。[#](#extend-luiti)\r\n7. luiti 命令行管理 Task。分析 Task 之间的依赖关系，包括依赖的和被依赖的。[#](#luiti-command-line)\r\n\r\n\r\n如果有相关问题，请参照 [FAQ](#FAQ) 里的说明。\r\n\r\nluigi 预备知识\r\n------------------------\r\n1. 英文文档   http://luigi.readthedocs.org/en/latest/index.html\r\n  （推荐看这个，官方详细文档, 含最新)\r\n2. 中文介绍   http://vincentzhwg.iteye.com/blog/2063388   (Luigi\r\n    －－基于 Python 语言的流式任务调度框架教程, 国内的人写的，不保\r\n   证正确性。)\r\n\r\n\r\nluigi 简单介绍\r\n------------------------\r\nluigi 的核心概念是用一系列 Task 类来管理任务，主要包含四个部分:\r\n\r\n1. 输出。放置在 `output` 方法里。比如 LocalTarget 和 hdfs.HdfsTarget\r\n   两种类型。\r\n2. 输入。放置在 `requires` 方法里, 该方法返回若干 Task instances\r\n    列表，每个 instance 都含有在 1. 里定义的 `output` 。\r\n3. 参数。 都继承自 Parameter ，比如 DateParameter 等。\r\n4. 执行逻辑。比如 `run` 或 `mapper` + `reducer` 方法。\r\n\r\n\r\n在写完 Task 业务实现和测试后，提交到 luigid 后台进程即可。 luigid\r\n会根据 `requires` 自动去处理任务依赖, 这是通过检查 `output` 是否存\r\n在而实现的(`output` 类里有 `exists` 方法)。并根据 Task 类名 + Task\r\n参数 保证在当前 luigid 后台进程里的唯一性。\r\n\r\n\r\nluiti 简单示例\r\n------------------------\r\n#### luigi 的写法示例。以下代码 Copy 自 [luigi官方示例](http://luigi.readthedocs.org/en/latest/example_top_artists.html)\r\n```python\r\nimport luigi\r\nfrom collections import defaultdict\r\n\r\nclass AggregateArtists(luigi.Task):\r\n    date_interval = luigi.DateIntervalParameter()\r\n\r\n    def output(self):\r\n        return luigi.LocalTarget(\"/data/artist_streams_%s.tsv\" % self.date_interval)\r\n\r\n    def requires(self):\r\n        return [Streams(date) for date in self.date_interval]\r\n\r\n    def run(self):\r\n        artist_count = defaultdict(int)\r\n\r\n        for input in self.input():\r\n            with input.open('r') as in_file:\r\n                for line in in_file:\r\n                    timestamp, artist, track = line.strip().split()\r\n                    artist_count[artist] += 1\r\n\r\n        with self.output().open('w') as out_file:\r\n            for artist, count in artist_count.iteritems():\r\n                print >> out_file, artist, count\r\n```\r\n\r\n#### 同一个例子的 luiti 写法\r\n\r\n* 第一个文件: `artist_project/luiti_tasks/artist_stream_day.py`\r\n\r\n```python\r\nfrom luiti import *\r\n\r\nclass ArtistStreamDay(StaticFile):\r\n\r\n    @cached_property\r\n    def filepath(self):\r\n        return \"/data/artist_streams_%s.tsv\" % self.date_str\r\n```\r\n\r\n* 第二个文件: `artist_project/luiti_tasks/aggregate_artists_week.py`\r\n```python\r\nfrom luiti import *\r\n\r\n@luigi.ref_tasks(\"ArtistStreamDay')\r\nclass AggregateArtistsWeek(TaskWeek):\r\n\r\n    def requires(self):\r\n        return [self.ArtistStreamDay(d1) for d1 in self.days_in_week]\r\n\r\n    def run(self):\r\n        artist_count = defaultdict(int)\r\n\r\n        for file1 in self.input():\r\n            for line2 in TargetUtils.line_read(file1):\r\n                timestamp, artist, track = line.strip().split()\r\n                artist_count[artist] += 1\r\n\r\n        with self.output().open('w') as out_file:\r\n            for artist, count in artist_count.iteritems():\r\n                print >> out_file, artist, count\r\n```\r\n\r\n优化说明:\r\n\r\n1. luiti 的 Task 类均直接内置了 `date_value` 属性，并转为 Arrow 类型。\r\n2. ArtistStreamDay 里的 `date_str` 由 `date_value` 转换而来，在初次调用后就被转成实例的属性了。\r\n3. `@luigi.ref_tasks` 就自动绑定了 ArtistStreamDay 到 AggregateArtistsWeek  的实例属性了，\r\n   所以可以用 `self.ArtistStreamDay(d1)` 形式来直接声明实例了。\r\n4. 在 AggregateArtistsWeek 继承了 `TaskWeek` 后就自动有了 `self.days_in_week` 属性了。\r\n5. `TargetUtils.line_read` 替换了原来两行代码需要完成的功能，直接返回一个迭代器(generator)。\r\n\r\n\r\n#### luiti 的 MapReduce 写法\r\n* 第一个文件: `artist_project/luiti_tasks/artist_stream_day.py`\r\n\r\n```python\r\nfrom luiti import *\r\n\r\nclass ArtistStreamDay(StaticFile):\r\n\r\n    @cached_property\r\n    def filepath(self):\r\n        return TargetUtils.hdfs(\"/data/artist_streams_%s.tsv\" % self.date_str\r\n```\r\n\r\n* 第二个文件: `artist_project/luiti_tasks/aggregate_artists_week.py`\r\n```python\r\nfrom luiti import *\r\n\r\n@luigi.ref_tasks(\"ArtistStreamDay')\r\nclass AggregateArtistsWeek(TaskWeekHadoop):\r\n\r\n    def requires(self):\r\n        return [self.ArtistStreamDay(d1) for d1 in self.days_in_week]\r\n\r\n    def mapper(self, line1):\r\n        timestamp, artist, track = line.strip().split()\r\n        yield artist, 1\r\n\r\n    def reducer(self, artist, counts):\r\n        yield artist, len(counts)\r\n```\r\n\r\n优化说明: 在 MapReduce 计算模式下，这种简单业务实际上比原来代码还精简。其他和原生 luigi 没多大区别。\r\n\r\n\r\n\r\n\r\n\r\n\r\n安装\r\n------------------------\r\n```bash\r\npip install luiti\r\n```\r\n\r\n或者最新源码\r\n\r\n```bash\r\ngit clone https://github.com/17zuoye/luiti.git\r\ncd luiti\r\npython setup.py install\r\n```\r\n\r\n\r\nluiti command line\r\n------------------------\r\n安装后就可以直接在当前 Shell 里使用 luiti 命令了, 比如:\r\n```text\r\n$ luiti\r\nusage: luiti [-h] {ls,new,generate,info,clean,run} ...\r\n\r\nLuiti tasks manager.\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n\r\nsubcommands:\r\n  valid subcommands\r\n\r\n  {ls,new,generate,info,clean,run}\r\n    ls                  list all current luiti tasks.\r\n    new                 create a new luiti project.\r\n    generate            generate a new luiti task python file.\r\n    info                show a detailed task.\r\n    clean               manage files that outputed by luiti tasks.\r\n    run                 run a luiti task.\r\n```\r\n\r\nCore concepts based on time management\r\n------------------------\r\n### 时间类型\r\n\r\n#### 基础继承类:\r\n0. TaskBase           (luigi.Task)\r\n1. TaskHour           (TaskBase)\r\n2. TaskDay            (TaskBase)\r\n3. TaskWeek           (TaskBase)\r\n4. TaskMonth          (TaskBase)\r\n5. TaskRange          (TaskBase)\r\n\r\n所以这里是可以扩展更多时间类型的, 并确保在 `TaskBase.DateTypes` 里也加上。\r\n\r\n#### Hadoop继承类:\r\n1. TaskDayHadoop      (luigi.hadoop.HadoopExt, TaskDay)\r\n2. TaskWeekHadoop     (luigi.hadoop.HadoopExt, TaskWeek)\r\n3. TaskRangeHadoop    (luigi.hadoop.HadoopExt, TaskRange)\r\n\r\n#### 其他类:\r\n1. RootTask           (luiti.Task)\r\n2. StaticFile         (luiti.Task)\r\n3. MongoImportTask    (TaskBase) # 导出 MR 结果到 mongodb 。\r\n\r\n\r\n### 时间库\r\n\r\n采用的时间类库是 [Arrow](http://crsmithdev.com/arrow/) , 每一个 Task\r\ninstance 具体引用的时间 instance 都是 arrow.Arrow 类型。\r\n\r\n在 luiti 插件里均直接转换到本地时区。如果需要自定义时间，请优先使用\r\n `ArrowParameter.get(*strs)` 和 `ArrowParameter.now()` 等 以保证都\r\n 转换到本地时区。\r\n\r\n\r\nTask 规范 和 内置属性 和 推荐做法\r\n------------------------\r\n### Task 命名规范\r\n1. 一个 Task 类，一个文件。\r\n2. Task 类为驼峰方式(比如 `EnglishStudentAllExamWeek` )，文件名为\r\n   小写加下划线方式(比如 `english_student_all_exam_week.py` ) 。\r\n3. Task 文件所位于的目录均为 `luiti_tasks`, 这样支持了 装饰器\r\n   `@luigi.ref_tasks(*tasks)` 相互惰性自动引用，也支持多项目目录\r\n   Task 引用。\r\n4. Task 类名必须以 Day, Week 等时间类型结尾，具体参考 `TaskBase.DateTypes` 。\r\n\r\n\r\n### Task 内置属性\r\n1. `date_value` 。强制参数, 即使是 Range 类型的 Task 也是需要的，这样\r\n   保证结果会 `output` 到某天的目录。另外在 `__init__` 时会被转换称\r\n   arrow.Arrow 的本地时区类型。\r\n2. `data_file` 。结果输出的绝对地址，字符串类型。\r\n3. `data_dir` 。结果输出的绝对地址目录，字符串类型。\r\n4. `root_dir` 。输出的根目录, `data_file` 和 `data_dir` 都是在其之下。\r\n5. `output` 。基本类输出到 LocalTarget , Hadoop类型会输出到 hdfs.HdfsTarget 。\r\n6. `date_str` 。返回 20140901 格式的时间字符串。\r\n7. `date_type` 。从类名中获取并返回 Day, Week 等字符串。\r\n8. `date_value_by_type_in_last` 。如果时间类型是 Week ，就返回上周一的\r\n   arrow.Arrow 。\r\n8. `date_value_by_type_in_begin` 。如果时间类型是 Week ，就返回当前周一的\r\n   零点。\r\n9. `date_value_by_type_in_end` 。如果时间类型是 Week ，就返回当前周日的\r\n   11:59:59。\r\n10. `pre_task_by_self` 。一般情况下返回当前时间类型的上个时间点的任务。\r\n   如果达到了该任务类型的时间边界，就返回 RootTask 。\r\n11. `is_reach_the_edge` 。在 17zuoye 的业务是学期边界。\r\n12. `instances_by_date_range`。类方法。返回属于某周期里的所有当前任务实例列表。\r\n13. `task_class`。返回当前 Task 类。\r\n\r\n\r\n### Task 推荐做法\r\n\r\n#### 缓存\r\n强烈推荐使用 [Werkzeug. The Python WSGI Utility Library](http://werkzeug.pocoo.org/) 实现的 `cached_property` , 是 Python 内置的 property 的缓存版本，惰性载入耗CPU和IO\r\n资源的字典数据。示例:\r\n\r\n```python\r\nclass AnotherBussinessDay(TaskDayHadoop):\r\n\r\n    def requires(self):\r\n        return [task1, task2, ...]\r\n\r\n    def mapper(self, line1):\r\n        k1, v1 = process(line1)\r\n        yield k1, v1\r\n\r\n    def reducer(self, k1, vs1):\r\n        for v1 in vs1:\r\n            v2 = func2(v1, self.another_dict)\r\n            yield k1, v2\r\n\r\n    @cached_property\r\n    def another_dict(self):\r\n        # lots of cpu/io\r\n        return big_dict\r\n```\r\n\r\n#### 全局实用工具\r\n1. os, re, json, defaultdict 等基本工具。\r\n2. arrow, ArrowParameter 时间处理工具。\r\n3. `cached_property`, 缓存里已介绍。\r\n4.  IOUtils, DateUtils, TargetUtils, HDFSUtils, MRUtils, MathUtils,\r\n     CommandUtils, CompressUtils, 使用见具体实现。\r\n\r\n\r\nTask decorators\r\n------------------------\r\n```python\r\n# 1. 惰性绑定相关 Task, 直接作为 instance property 使用。\r\n@luigi.ref_tasks(*tasks)\r\n\r\n# 2. 检查当前日期是否满足Task依赖的时间区间。\r\n@luigi.check_date_range()\r\n\r\n# 3. 检查 Task 可以运行的时间点。\r\n@luigi.check_runtime_range(hour_num=[4,5,6], weekday_num=[1])\r\n\r\n# 4. 绑定除了默认的 `date_file` 之外的输出文件名。同时兼容了任务失败时的删除处理。\r\n@luigi.persist_files(*files)\r\n\r\nclass AnotherBussinessDay(TaskDayHadoop):\r\n    pass\r\n```\r\n\r\n\r\n\r\nMapReduce related\r\n------------------------\r\n#### 任务失败时的临时文件处理\r\n执行 MR 时, luigi 会先输出到有时间戳的临时文件。如果任务成功，则重命名\r\n到原先任务指定的名字。如果任务失败，则 YARN 会自动删除该临时文件。\r\n\r\n#### MR 键值解析\r\nluiti 推荐是 组合键 unicode 作为 Map Key, 而 dict (序列化为json格式) 作为 Reduce Value 。推荐使\r\n用 `MRUtils.split_mr_kv`, 该函数会返回 [unicode, dict] 结果。\r\n\r\n#### MR 键的组合处理\r\n1. `MRUtils.concat_prefix_keys(*keys)` 。组合多个键。\r\n2. `MRUtils.is_mr_line(line1)` 。判断是否是 MR 格式的行输出。\r\n3. `MRUtils.split_prefix_keys(line_part_a)` 。用默认分隔符 分割, 返回字符串列表。\r\n4. `MRUtils.select_prefix_keys(line_part_a, idxes=None)` 。用索引来取得组合键的\r\n    某些部分，并支持修复因 json 序列化带来的误操作（在首尾多了 `\"` 引号）。\r\n\r\n#### MR 读入文件处理, generator 方式\r\n1. 原始读入。 `TargetUtils.line_read(hdfs1)`。返回 unicode。\r\n2. JSON读入。 `TargetUtils.json_read(hdfs1)`。返回 json 相关类型。\r\n3. MR读入。   `TargetUtils.mr_read(hdfs1)`。返回 [unicode, json 相关类型] 键值对形式。\r\n\r\n示例:\r\n````python\r\nfor k1, v1 in MRUtils.mr_read(hdfs1):\r\n    isinstance(k1, unicode)\r\n    isinstance(v1, dict)\r\n```\r\n\r\n#### HDFS 文件对象\r\n使用 `TargetUtils.hdfs(path1)` 。该函数同时兼容了 MR 按 `part-00000`\r\n分文件块的数据格式。\r\n\r\n#### MR test\r\n1. 给继承 Hadoop 相关Task基类 的 具体业务 Task 加上 `mrtest_input` 和\r\n    `mrtest_output` 两个方法，分别用于 MR 的文本输入和输出。\r\n2. 在测试代码里加上如下代码，luiti 就会自动给 `mr_task_names` 里的所有 Task\r\n   生成测试用例，然后按正常方式跑 Python 测试用例即可。\r\n3. 还可以用 `mrtest_attrs` 生成该实例上的多个字典属性。\r\n\r\n```python\r\nfrom luiti import MrTestCase\r\n\r\n@MrTestCase\r\nclass TestMapReduce(unittest.TestCase):\r\n    mr_task_names = [\r\n            'ClassEnglishAllExamWeek',\r\n            ...\r\n           ]\r\n\r\nif __name__ == '__main__': unittest.main()\r\n```\r\n\r\n\r\nManage multiple projects in luiti\r\n------------------------\r\n#### 具体单个项目的目录结构\r\n每个项目目录结构建议为以下格式，即可以当作一个正规的 Python package 来使用， 比如:\r\n\r\n```text\r\nproject_A                                            --- project directory\r\n  setup.py                                           --- Python package install script\r\n  README.markdown                                    --- project README\r\n  project_A/                                         --- Python package install directory\r\n  ├── __init__.py                                    --- mark current directories on disk as a Python package directories\r\n  └── luiti_tasks                                    --- a directory name which indicates it contains several luiti tasks\r\n      ├── __init__.py                                --- mark current directories on disk as a Python package directories\r\n      ├── __init_luiti.py                            --- initialize luiti environment variables\r\n      ├── exam_logs_english_app_day.py               --- an example luiti task\r\n      ├── ..._day.py                                 --- another example luiti task\r\n      └── templates                                  --- some libraries\r\n            ├── __init__.py\r\n            └── ..._template.py\r\n```\r\n\r\n在安装好 `luiti` 后，运行如下命令行即可生成上述的项目基本目录结构，\r\n```bash\r\nluiti new project_A\r\n```\r\n\r\n这个树目录其实就是可以用来安装 package 的 Python 项目, 在根的 `project_A` 目录\r\n下运行 `python setup.py install` 即可把当前项目安装到当前 Python 环境的 package\r\n引用路径(即 `sys.path` )下。\r\n\r\n\r\n#### 如何关联另一个项目的某个 Task\r\n每个项目都是类似 `project_A/luiti_tasks/another_feature_day.py` 结构，在 `__init_luiti.py` 只要\r\n用 `luigi.plug_packages(\"project_B\", \"project_C==0.0.2\"])` 后， 像 `@luigi.ref_tasks(\"ArtistStreamDay')`\r\n就会现在当前 `project_A`, 和相关的 `project_B`, `project_C` 里去找 ArtistStreamDay Task 了。\r\n\r\n\r\nExtend luiti\r\n------------------------\r\n使用 TaskBase 里自带 extend 类方法扩展或者覆写默认属性或方法，比如:\r\n\r\n```python\r\nTaskWeek.extend({\r\n    'property_1' : lambda self: \"property_2\",\r\n})\r\n```\r\n\r\n`extend` 类方法同时兼容了 `function`, `property`, `cached_property`,\r\n或者其他任意类属性。在覆写 `property` 和 `cached_property`\r\n传一个函数值即可，`extend` 会自动转化为本来的 `property` 和\r\n`cached_property` 类型。\r\n\r\nFAQ\r\n------------------------\r\nQ: How atomic file is supported?\r\n\r\nA: As luigi's document mentioned that \"Simple class that writes to a temp file and moves it on close()\r\n    Also cleans up the temp file if close is not invoked\", so use the `self.input().open(\"r\")` or\r\n    `self.output().open(\"w\")` instead of `open(\"some_file\", \"w\")`.\r\n\r\nQ: Can luigi detect the interdependent tasks?\r\n\r\nA: It's not question inside of luigi, but it's a question about [topological sorting](https://en.wikipedia.org/wiki/Topological_sorting)\r\n   as a general computer science topic. The task scheduler is implemented at `luigi/scheduler.py` .\r\n\r\n\r\n\r\nIf you have other unresolved questions, please feel free to ask\r\nquestions at [issues](https://github.com/17zuoye/luiti/issues).\r\n\r\n\r\nRun tests\r\n------------------------\r\n```bash\r\n./tests/run.sh\r\n```\r\n\r\nLicense\r\n------------------------\r\nMIT. David Chen @ 17zuoye.\r\n","google":"UA-57207964-1","note":"Don't delete this file! It's used internally to help with page regeneration."}