{"name":"Luiti","tagline":"luiti = luigi + time.","body":"Luiti\r\n========================\r\nLuigi是一套基于python语言构建的复杂流式批处理任务管理系统。它也仅仅是一个任务\r\n调度系统，具体逻辑全都由 Task 自己去实现，比如分布式计算交由 Hadoop 里的 YARN 实现处理。\r\n\r\nLuiti 是构建于 Luigi 之上的主要作用于时间管理相关的插件, 即\r\n Luiti = Luigi + time。\r\n\r\n\r\n\r\nluigi 预备知识\r\n------------------------\r\n1. 英文文档   http://luigi.readthedocs.org/en/latest/index.html\r\n  （推荐看这个，官方详细文档, 含最新)\r\n2. 中文介绍   http://vincentzhwg.iteye.com/blog/2063388   (Luigi\r\n    －－基于Python语言的流式任务调度框架教程, 国内的人写的，不保\r\n   证正确性。)\r\n\r\n\r\nluigi 简单介绍\r\n------------------------\r\nluigi 的核心概念是用一系列 Task 类来管理任务，主要包含四个部分:\r\n\r\n1. 输出。放置在 `output` 方法里。比如 LocalTarget 和 hdfs.HdfsTarget\r\n   两种类型。\r\n2. 输入。放置在 `requires` 方法里, 该方法返回若干 Task instances\r\n    列表，每个 instance 都含有在 1. 里定义的 `output` 。\r\n3. 参数。 都继承自 Parameter ，比如 DateParameter 等。\r\n4. 执行逻辑。比如 `run` 或 `mapper` + `reducer` 方法。\r\n\r\n\r\n在写完 Task 业务实现和测试后，提交到 luigid 后台进程即可。 luigid\r\n会根据 `requires` 自动去处理任务依赖, 这是通过检查 `output` 是否存\r\n在而实现的(`output` 类里有 `exists` 方法)。并根据 Task 类名 + Task\r\n参数 保证在当前 luigid 后台进程里的唯一性。\r\n\r\n\r\nluiti 简单示例\r\n------------------------\r\n```python\r\nclass AggregateArtists(luigi.Task):\r\n    date_interval = luigi.DateIntervalParameter()\r\n\r\n    def output(self):\r\n        return luigi.LocalTarget(\"data/artist_streams_%s.tsv\" % self.date_interval)\r\n\r\n    def requires(self):\r\n        return [Streams(date) for date in self.date_interval]\r\n\r\n    def run(self):\r\n        artist_count = defaultdict(int)\r\n\r\n        for input in self.input():\r\n            with input.open('r') as in_file:\r\n                for line in in_file:\r\n                    timestamp, artist, track = line.strip().split()\r\n                    artist_count[artist] += 1\r\n\r\n        with self.output().open('w') as out_file:\r\n            for artist, count in artist_count.iteritems():\r\n                print >> out_file, artist, count\r\n```\r\n\r\n以上代码 Copy 自 [luigi官方示例](http://luigi.readthedocs.org/en/latest/example_top_artists.html)\r\n\r\n\r\n\r\n安装\r\n------------------------\r\n```bash\r\npip install luiti\r\n```\r\n\r\n或者最新源码\r\n\r\n```bash\r\ngit clone https://github.com/17zuoye/luiti.git\r\ncd luiti\r\npython setup.py install\r\n```\r\n\r\n\r\nluiti 命令行\r\n------------------------\r\n安装后就可以直接在当前 Shell 里使用 luiti 命令了, 比如:\r\n```text\r\n$ luiti\r\nusage: luiti [-h] {tasks,files,run} ...\r\n\r\nLuiti tasks manager.\r\n\r\noptional arguments:\r\n  -h, --help         show this help message and exit\r\n\r\nsubcommands:\r\n  valid subcommands\r\n\r\n  {tasks,files,run}\r\n    tasks            manage luiti tasks.\r\n    files            manage files that outputed by luiti tasks.\r\n    run              run a luiti task.\r\n```\r\n\r\n基于时间管理的核心概念\r\n------------------------\r\n\r\n### 时间类型\r\n\r\n#### 基础继承类:\r\n0. TaskBase           (luigi.Task)\r\n1. TaskHour           (TaskBase)\r\n2. TaskDay            (TaskBase)\r\n3. TaskWeek           (TaskBase)\r\n4. TaskMonth          (TaskBase)\r\n5. TaskRange          (TaskBase)\r\n\r\n所以这里是可以扩展更多时间类型的, 并确保在 `TaskBase.DateTypes` 里也加上。\r\n\r\n#### Hadoop继承类:\r\n1. TaskDayHadoop      (luigi.hadoop.HadoopExt, TaskDay)\r\n2. TaskWeekHadoop     (luigi.hadoop.HadoopExt, TaskWeek)\r\n3. TaskRangeHadoop    (luigi.hadoop.HadoopExt, TaskRange)\r\n\r\n#### 其他类:\r\n1. RootTask           (luiti.Task)\r\n2. StaticFile         (luiti.Task)\r\n3. MongoTask          (TaskBase) # 导出 MR 结果到 mongodb 。\r\n\r\n\r\n### 时间库\r\n\r\n采用的时间类库是 [Arrow](http://crsmithdev.com/arrow/) , 每一个 Task\r\ninstance 具体引用的时间 instance 都是 arrow.Arrow 类型。\r\n\r\n在 luiti 插件里均直接转换到本地时区。如果需要自定义时间，请优先使用\r\n `ArrowParameter.get(*strs)` 和 `ArrowParameter.now()` 等 以保证都\r\n 转换到本地时区。\r\n\r\n\r\nTask 规范 和 内置属性 和 推荐做法\r\n------------------------\r\n### Task 命名规范\r\n1. 一个 Task 类，一个文件。\r\n2. Task 类为驼峰方式(比如 `EnglishStudentAllExamWeek` )，文件名为\r\n   小写加下划线方式(比如 `english_student_all_exam_week.py` ) 。\r\n3. Task 文件所位于的目录均为 `luiti_tasks`, 这样支持了 装饰器\r\n   `@luigi.ref_tasks(*tasks)` 相互惰性自动引用，也支持多项目目录\r\n   Task 引用。\r\n4. Task 类名必须以 Day, Week 等时间类型结尾，具体参考 `TaskBase.DateTypes` 。\r\n\r\n\r\n### Task 内置属性\r\n1. `date_value` 。强制参数, 即使是 Range 类型的 Task 也是需要的，这样\r\n   保证结果会 `output` 到某天的目录。另外在 `__init__` 时会被转换称\r\n   arrow.Arrow 的本地时区类型。\r\n2. `data_file` 。结果输出的绝对地址，字符串类型。\r\n3. `data_dir` 。结果输出的绝对地址目录，字符串类型。\r\n4. `root_dir` 。输出的根目录, `data_file` 和 `data_dir` 都是在其之下。\r\n5. `output` 。基本类输出到 LocalTarget , Hadoop类型会输出到 hdfs.HdfsTarget 。\r\n6. `date_str` 。返回 20140901 格式的时间字符串。\r\n7. `date_type` 。从类名中获取并返回 Day, Week 等字符串。\r\n8. `date_value_by_type_in_last` 。如果时间类型是 Week ，就返回上周一的\r\n   arrow.Arrow 。\r\n8. `date_value_by_type_in_begin` 。如果时间类型是 Week ，就返回当前周一的\r\n   零点。\r\n9. `date_value_by_type_in_end` 。如果时间类型是 Week ，就返回当前周日的\r\n   11:59:59。\r\n10. `pre_task_by_self` 。一般情况下返回当前时间类型的上个时间点的任务。\r\n   如果达到了该任务类型的时间边界，就返回 RootTask 。\r\n11. `is_reach_the_edge` 。在 17zuoye 的业务是学期边界。\r\n12. `instances_by_date_range`。类方法。返回属于某周期里的所有当前任务实例列表。\r\n13. `task_class`。返回当前 Task 类。\r\n\r\n\r\n### Task 推荐做法\r\n\r\n#### 缓存\r\n强烈推荐使用 [Werkzeug. The Python WSGI Utility Library](http://werkzeug.pocoo.org/) 实现的 `cached_property` , 是 Python 内置的 property 的缓存版本，惰性载入耗CPU和IO\r\n资源的字典数据。示例:\r\n\r\n```python\r\nclass AnotherBussinessDay(TaskDayHadoop):\r\n\r\n    def requires(self):\r\n        return [task1, task2, ...]\r\n\r\n    def mapper(self, line1):\r\n        k1, v1 = process(line1)\r\n        yield k1, v1\r\n\r\n    def reducer(self, k1, vs1):\r\n        for v1 in vs1:\r\n            v2 = func2(v1, self.another_dict)\r\n            yield k1, v2\r\n\r\n    @cached_property\r\n    def another_dict(self):\r\n        # lots of cpu/io\r\n        return big_dict\r\n```\r\n\r\n#### 全局实用工具\r\n1. os, re, json, defaultdict 等基本工具。\r\n2. arrow, ArrowParameter 时间处理工具。\r\n3. `cached_property`, 缓存里已介绍。\r\n4.  IOUtils, DateUtils, TargetUtils, HDFSUtils, MRUtils, MathUtils,\r\n     CommandUtils, CompressUtils, 使用见具体实现。\r\n\r\nTask 装饰器\r\n------------------------\r\n```python\r\n# 1. 惰性绑定相关 Task, 直接作为 instance property 使用。\r\n@luigi.ref_tasks(*tasks)\r\n\r\n# 2. 检查当前日期是否满足Task依赖的时间区间。\r\n@luigi.check_date_range()\r\n\r\n# 3. 检查 Task 可以运行的时间点。\r\n@luigi.check_runtime_range(hour_num=[4,5,6], weekday_num=[1])\r\n\r\n# 4. 绑定除了默认的 `date_file` 之外的输出文件名。同时兼容了任务失败时的删除处理。\r\n@luigi.persist_files(*files)\r\n\r\nclass AnotherBussinessDay(TaskDayHadoop):\r\n    pass\r\n```\r\n\r\n\r\nMapReduce 相关\r\n------------------------\r\n#### 任务失败时的临时文件处理\r\n执行 MR 时, luigi 会先输出到有时间戳的临时文件。如果任务成功，则重命名\r\n到原先任务指定的名字。如果任务失败，则 YARN 会自动删除该临时文件。\r\n\r\n#### MR 键值解析\r\nluiti 推荐是 组合键 unicode 作为 Map Key, 而 dict (序列化为json格式) 作为 Reduce Value 。推荐使\r\n用 `MRUtils.split_mr_kv`, 该函数会返回 [unicode, dict] 结果。\r\n\r\n#### MR 键的组合处理\r\n1. `MRUtils.concat_prefix_keys(*keys)` 。组合多个键。\r\n2. `MRUtils.is_mr_line(line1)` 。判断是否是 MR 格式的行输出。\r\n3. `MRUtils.split_prefix_keys(line_part_a)` 。用默认分隔符 分割, 返回字符串列表。\r\n4. `MRUtils.select_prefix_keys(line_part_a, idxes=None)` 。用索引来取得组合键的\r\n    某些部分，并支持修复因 json 序列化带来的误操作（在首尾多了 `\"` 引号）。\r\n\r\n#### MR 读入文件处理, generate 方式\r\n1. 原始读入。 `TargetUtils.line_read(hdfs1)`。返回 unicode。\r\n2. JSON读入。 `TargetUtils.json_read(hdfs1)`。返回 json 相关类型。\r\n3. MR读入。   `TargetUtils.mr_read(hdfs1)`。返回 [unicode, json 相关类型] 键值对形式。\r\n\r\n示例:\r\n````python\r\nfor k1, v1 in MRUtils.mr_read(hdfs1):\r\n    isinstance(k1, unicode)\r\n    isinstance(v1, dict)\r\n```\r\n\r\n#### HDFS 文件对象\r\n使用 `TargetUtils.hdfs(path1)` 。该函数同时兼容了 MR 按 `part-00000`\r\n分文件块的数据格式。\r\n\r\n#### MR 测试\r\n1. 给继承 Hadoop 相关Task基类 的 具体业务 Task 加上 `mrtest_input` 和\r\n    `mrtest_output` 两个方法，分别用于 MR 的文本输入和输出。\r\n2. 在测试代码里加上如下代码，luiti 就会自动给 `mr_task_names` 里的所有 Task\r\n   生成测试用例，然后按正常方式跑 Python 测试用例即可。\r\n3. 还可以用 `mrtest_attrs` 生成该实例上的多个字典属性。\r\n\r\n```python\r\nfrom luiti import MrTestCase\r\n\r\n@MrTestCase\r\nclass TestMapReduce(unittest.TestCase):\r\n    mr_task_names = [\r\n            'ClassEnglishAllExamWeek',\r\n            ...\r\n           ]\r\n\r\nif __name__ == '__main__': unittest.main()\r\n```\r\n\r\n\r\nluiti 多项目管理\r\n------------------------\r\n#### 解决方案\r\n直接 clone 依赖项目(含 `luiti_tasks` 目录)到当前项目的 `luiti_tasks`\r\n项目下即可。\r\n\r\n#### 实现细节\r\n为了方便在具体 Task 里 相对引用在当前 `luiti_tasks` 目录下的子目录里的\r\nPython 文件，比如 `from .utils import SomeUtils` ，而该 utils\r\n的实际目录是 `/curr_project/luiti_tasks/utils/`。\r\n\r\n如果直接把 `luiti_tasks` 放入到 Python 里的 `sys.path` 里的话，就会引起\r\n`ValueError: Attempted relative import in non-package` 错误。而 luiti\r\n对多 `luiti_tasks` 的引用也是通过动态修改 `sys.path` 实现的。\r\n\r\n扩展 luiti\r\n------------------------\r\n使用 TaskBase 里自带 extend 类方法扩展或者覆写默认属性或方法，比如:\r\n\r\n```python\r\nTaskWeek.extend({\r\n    'property_1' : lambda self: \"property_2\",\r\n})\r\n```\r\n\r\n`extend` 类方法同时兼容了 `function`, `property`, `cached_property`,\r\n或者其他任意类属性。在覆写 `property` 和 `cached_property`\r\n传一个函数值即可，`extend` 会自动转化为本来的 `property` 和\r\n`cached_property` 类型。\r\n\r\n\r\nRun tests\r\n------------------------\r\n```bash\r\n./tests/run.sh\r\n```\r\n\r\n\r\nLicense\r\n------------------------\r\nMIT. David Chen @ 17zuoye.\r\n","google":"UA-57207964-1","note":"Don't delete this file! It's used internally to help with page regeneration."}