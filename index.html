<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Luiti by 17zuoye</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Luiti</h1>
      <h2 class="project-tagline">luiti = luigi + time.</h2>
      <a href="https://github.com/17zuoye/luiti" class="btn">View on GitHub</a>
      <a href="https://github.com/17zuoye/luiti/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/17zuoye/luiti/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="luiti" class="anchor" href="#luiti" aria-hidden="true"><span class="octicon octicon-link"></span></a>Luiti</h1>

<p><a href="https://travis-ci.org/17zuoye/luiti"><img src="https://img.shields.io/travis/17zuoye/luiti/master.svg?style=flat" alt="Build Status"></a>
<a href="https://coveralls.io/r/17zuoye/luiti"><img src="https://coveralls.io/repos/17zuoye/luiti/badge.svg" alt="Coverage Status"></a>
<a href="https://landscape.io/github/17zuoye/luiti/master"><img src="https://landscape.io/github/17zuoye/luiti/master/landscape.svg?style=flat" alt="Health"></a>
<a href="https://pypi.python.org/pypi/luiti"><img src="https://img.shields.io/pypi/dm/luiti.svg?style=flat" alt="Download"></a>
<a href="https://pypi.python.org/pypi/luiti"><img src="https://img.shields.io/pypi/l/luiti.svg?style=flat" alt="License"></a>
<a href="https://pypi.python.org/pypi/luiti"><img src="https://pypip.in/py_versions/luiti/badge.svg?style=flat" alt="Python Versions"></a></p>

<p>Luigi 是一套基于 Python 语言构建的复杂流式批处理任务管理系统。它也仅仅是一个任务
调度系统，具体逻辑全都由 Task 自己去实现，比如分布式计算交由 Hadoop 里的 YARN 实现处理。</p>

<p>Luiti 是构建于 Luigi 之上的主要作用于时间管理相关的插件, 即
 Luiti = Luigi + time。</p>

<h2>
<a id="luiti-优势" class="anchor" href="#luiti-%E4%BC%98%E5%8A%BF" aria-hidden="true"><span class="octicon octicon-link"></span></a>luiti 优势</h2>

<ol>
<li>按时间和业务类型等属性去多目录划分基础表, 中间表, 统计表 等。<a href="#core-concepts-based-on-time-management">#</a>
</li>
<li>支持无缝 多项目 多版本 管理, 兼容常规 Python 库引用机制。<a href="#manage-multiple-projects-in-luiti">#</a>
</li>
<li>任务的运行时间和业务时间的满足条件检查。<a href="#task-decorators">#</a>
</li>
<li>众多 MapReduce / IO 实用操作函数。<a href="#mapreduce-related">#</a>
</li>
<li>基于输入输出数据的 MapReduce 测试方案。<a href="#mr-test">#</a>
</li>
<li>内置支持 Task 基类扩展。<a href="#extend-luiti">#</a>
</li>
<li>luiti 命令行管理 Task。分析 Task 之间的依赖关系，包括依赖的和被依赖的。<a href="#luiti-command-line">#</a>
</li>
</ol>

<p>如果有相关问题，请参照 <a href="#FAQ">FAQ</a> 里的说明。</p>

<h2>
<a id="luigi-预备知识" class="anchor" href="#luigi-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86" aria-hidden="true"><span class="octicon octicon-link"></span></a>luigi 预备知识</h2>

<ol>
<li>英文文档   <a href="http://luigi.readthedocs.org/en/latest/index.html">http://luigi.readthedocs.org/en/latest/index.html</a>
（推荐看这个，官方详细文档, 含最新)</li>
<li>中文介绍   <a href="http://vincentzhwg.iteye.com/blog/2063388">http://vincentzhwg.iteye.com/blog/2063388</a>   (Luigi
－－基于 Python 语言的流式任务调度框架教程, 国内的人写的，不保
证正确性。)</li>
</ol>

<h2>
<a id="luigi-简单介绍" class="anchor" href="#luigi-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a>luigi 简单介绍</h2>

<p>luigi 的核心概念是用一系列 Task 类来管理任务，主要包含四个部分:</p>

<ol>
<li>输出。放置在 <code>output</code> 方法里。比如 LocalTarget 和 hdfs.HdfsTarget
两种类型。</li>
<li>输入。放置在 <code>requires</code> 方法里, 该方法返回若干 Task instances
列表，每个 instance 都含有在 1. 里定义的 <code>output</code> 。</li>
<li>参数。 都继承自 Parameter ，比如 DateParameter 等。</li>
<li>执行逻辑。比如 <code>run</code> 或 <code>mapper</code> + <code>reducer</code> 方法。</li>
</ol>

<p>在写完 Task 业务实现和测试后，提交到 luigid 后台进程即可。 luigid
会根据 <code>requires</code> 自动去处理任务依赖, 这是通过检查 <code>output</code> 是否存
在而实现的(<code>output</code> 类里有 <code>exists</code> 方法)。并根据 Task 类名 + Task
参数 保证在当前 luigid 后台进程里的唯一性。</p>

<h2>
<a id="luiti-简单示例" class="anchor" href="#luiti-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>luiti 简单示例</h2>

<h4>
<a id="luigi-的写法示例以下代码-copy-自-luigi官方示例" class="anchor" href="#luigi-%E7%9A%84%E5%86%99%E6%B3%95%E7%A4%BA%E4%BE%8B%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81-copy-%E8%87%AA-luigi%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>luigi 的写法示例。以下代码 Copy 自 <a href="http://luigi.readthedocs.org/en/latest/example_top_artists.html">luigi官方示例</a>
</h4>

<div class="highlight highlight-python"><pre><span class="pl-k">import</span> luigi
<span class="pl-k">from</span> collections <span class="pl-k">import</span> defaultdict

<span class="pl-k">class</span> <span class="pl-en">AggregateArtists</span>(<span class="pl-e">luigi.Task</span>):
    date_interval <span class="pl-k">=</span> luigi.DateIntervalParameter()

    <span class="pl-k">def</span> <span class="pl-en">output</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> luigi.LocalTarget(<span class="pl-s"><span class="pl-pds">"</span>/data/artist_streams_<span class="pl-c1">%s</span>.tsv<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-v">self</span>.date_interval)

    <span class="pl-k">def</span> <span class="pl-en">requires</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> [Streams(date) <span class="pl-k">for</span> date <span class="pl-k">in</span> <span class="pl-v">self</span>.date_interval]

    <span class="pl-k">def</span> <span class="pl-en">run</span>(<span class="pl-smi">self</span>):
        artist_count <span class="pl-k">=</span> defaultdict(<span class="pl-c1">int</span>)

        <span class="pl-k">for</span> <span class="pl-c1">input</span> <span class="pl-k">in</span> <span class="pl-v">self</span>.input():
            <span class="pl-k">with</span> <span class="pl-c1">input</span>.open(<span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>) <span class="pl-k">as</span> in_file:
                <span class="pl-k">for</span> line <span class="pl-k">in</span> in_file:
                    timestamp, artist, track <span class="pl-k">=</span> line.strip().split()
                    artist_count[artist] <span class="pl-k">+=</span> <span class="pl-c1">1</span>

        <span class="pl-k">with</span> <span class="pl-v">self</span>.output().open(<span class="pl-s"><span class="pl-pds">'</span>w<span class="pl-pds">'</span></span>) <span class="pl-k">as</span> out_file:
            <span class="pl-k">for</span> artist, count <span class="pl-k">in</span> artist_count.iteritems():
                <span class="pl-k">print</span> <span class="pl-k">&gt;&gt;</span> out_file, artist, count</pre></div>

<h4>
<a id="同一个例子的-luiti-写法" class="anchor" href="#%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E7%9A%84-luiti-%E5%86%99%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>同一个例子的 luiti 写法</h4>

<ul>
<li>第一个文件: <code>artist_project/luiti_tasks/artist_stream_day.py</code>
</li>
</ul>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> luiti <span class="pl-k">import</span> <span class="pl-k">*</span>

<span class="pl-k">class</span> <span class="pl-en">ArtistStreamDay</span>(<span class="pl-e">StaticFile</span>):

    <span class="pl-en">@cached_property</span>
    <span class="pl-k">def</span> <span class="pl-en">filepath</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>/data/artist_streams_<span class="pl-c1">%s</span>.tsv<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-v">self</span>.date_str</pre></div>

<ul>
<li>第二个文件: <code>artist_project/luiti_tasks/aggregate_artists_week.py</code>
</li>
</ul>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> luiti <span class="pl-k">import</span> <span class="pl-k">*</span>

<span class="pl-en">@</span><span class="pl-en">luigi.ref_tasks</span>(<span class="pl-s"><span class="pl-pds">"</span>ArtistStreamDay')<span class="pl-ii"></span></span>
<span class="pl-k">class</span> <span class="pl-en">AggregateArtistsWeek</span>(<span class="pl-e">TaskWeek</span>):

    <span class="pl-k">def</span> <span class="pl-en">requires</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> [<span class="pl-v">self</span>.ArtistStreamDay(d1) <span class="pl-k">for</span> d1 <span class="pl-k">in</span> <span class="pl-v">self</span>.days_in_week]

    <span class="pl-k">def</span> <span class="pl-en">run</span>(<span class="pl-smi">self</span>):
        <span class="pl-smi">artist_count</span> <span class="pl-k">=</span> defaultdict(<span class="pl-c1">int</span>)

        <span class="pl-k">for</span> file1 <span class="pl-k">in</span> <span class="pl-v">self</span>.input():
            <span class="pl-k">for</span> line2 <span class="pl-k">in</span> TargetUtils.line_read(file1):
                timestamp, artist, <span class="pl-smi">track</span> <span class="pl-k">=</span> line.strip().split()
                artist_count[artist] <span class="pl-k">+=</span> <span class="pl-c1">1</span>

        <span class="pl-k">with</span> <span class="pl-v">self</span>.output().open(<span class="pl-s"><span class="pl-pds">'</span>w<span class="pl-pds">'</span></span>) <span class="pl-k">as</span> out_file:
            <span class="pl-k">for</span> artist, count <span class="pl-k">in</span> artist_count.iteritems():
                <span class="pl-k">print</span> <span class="pl-k">&gt;&gt;</span> out_file, artist, count</pre></div>

<p>优化说明:</p>

<ol>
<li>luiti 的 Task 类均直接内置了 <code>date_value</code> 属性，并转为 Arrow 类型。</li>
<li>ArtistStreamDay 里的 <code>date_str</code> 由 <code>date_value</code> 转换而来，在初次调用后就被转成实例的属性了。</li>
<li>
<code>@luigi.ref_tasks</code> 就自动绑定了 ArtistStreamDay 到 AggregateArtistsWeek  的实例属性了，
所以可以用 <code>self.ArtistStreamDay(d1)</code> 形式来直接声明实例了。</li>
<li>在 AggregateArtistsWeek 继承了 <code>TaskWeek</code> 后就自动有了 <code>self.days_in_week</code> 属性了。</li>
<li>
<code>TargetUtils.line_read</code> 替换了原来两行代码需要完成的功能，直接返回一个迭代器(generator)。</li>
</ol>

<h4>
<a id="luiti-的-mapreduce-写法" class="anchor" href="#luiti-%E7%9A%84-mapreduce-%E5%86%99%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>luiti 的 MapReduce 写法</h4>

<ul>
<li>第一个文件: <code>artist_project/luiti_tasks/artist_stream_day.py</code>
</li>
</ul>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> luiti <span class="pl-k">import</span> <span class="pl-k">*</span>

<span class="pl-k">class</span> <span class="pl-en">ArtistStreamDay</span>(<span class="pl-e">StaticFile</span>):

    <span class="pl-en">@cached_property</span>
    <span class="pl-k">def</span> <span class="pl-en">filepath</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> TargetUtils.hdfs(<span class="pl-s"><span class="pl-pds">"</span>/data/artist_streams_<span class="pl-c1">%s</span>.tsv<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-v">self</span>.date_str</pre></div>

<ul>
<li>第二个文件: <code>artist_project/luiti_tasks/aggregate_artists_week.py</code>
</li>
</ul>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> luiti <span class="pl-k">import</span> <span class="pl-k">*</span>

<span class="pl-en">@</span><span class="pl-en">luigi.ref_tasks</span>(<span class="pl-s"><span class="pl-pds">"</span>ArtistStreamDay')<span class="pl-ii"></span></span>
<span class="pl-k">class</span> <span class="pl-en">AggregateArtistsWeek</span>(<span class="pl-e">TaskWeekHadoop</span>):

    <span class="pl-k">def</span> <span class="pl-en">requires</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> [<span class="pl-v">self</span>.ArtistStreamDay(d1) <span class="pl-k">for</span> d1 <span class="pl-k">in</span> <span class="pl-v">self</span>.days_in_week]

    <span class="pl-k">def</span> <span class="pl-en">mapper</span>(<span class="pl-smi">self</span>, <span class="pl-smi">line1</span>):
        timestamp, artist, <span class="pl-smi">track</span> <span class="pl-k">=</span> line.strip().split()
        <span class="pl-k">yield</span> artist, <span class="pl-c1">1</span>

    <span class="pl-k">def</span> <span class="pl-en">reducer</span>(<span class="pl-smi">self</span>, <span class="pl-smi">artist</span>, <span class="pl-smi">counts</span>):
        <span class="pl-k">yield</span> artist, <span class="pl-c1">len</span>(counts)</pre></div>

<p>优化说明: 在 MapReduce 计算模式下，这种简单业务实际上比原来代码还精简。其他和原生 luigi 没多大区别。</p>

<h2>
<a id="安装" class="anchor" href="#%E5%AE%89%E8%A3%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h2>

<div class="highlight highlight-bash"><pre>pip install luiti</pre></div>

<p>或者最新源码</p>

<div class="highlight highlight-bash"><pre>git clone https://github.com/17zuoye/luiti.git
<span class="pl-c1">cd</span> luiti
python setup.py install</pre></div>

<h2>
<a id="luiti-command-line" class="anchor" href="#luiti-command-line" aria-hidden="true"><span class="octicon octicon-link"></span></a>luiti command line</h2>

<p>安装后就可以直接在当前 Shell 里使用 luiti 命令了, 比如:</p>

<pre lang="text"><code>$ luiti
usage: luiti [-h] {ls,new,generate,info,clean,run} ...

Luiti tasks manager.

optional arguments:
  -h, --help            show this help message and exit

subcommands:
  valid subcommands

  {ls,new,generate,info,clean,run}
    ls                  list all current luiti tasks.
    new                 create a new luiti project.
    generate            generate a new luiti task python file.
    info                show a detailed task.
    clean               manage files that outputed by luiti tasks.
    run                 run a luiti task.
</code></pre>

<h2>
<a id="core-concepts-based-on-time-management" class="anchor" href="#core-concepts-based-on-time-management" aria-hidden="true"><span class="octicon octicon-link"></span></a>Core concepts based on time management</h2>

<h3>
<a id="时间类型" class="anchor" href="#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>时间类型</h3>

<h4>
<a id="基础继承类" class="anchor" href="#%E5%9F%BA%E7%A1%80%E7%BB%A7%E6%89%BF%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础继承类:</h4>

<ol>
<li>TaskBase           (luigi.Task)</li>
<li>TaskHour           (TaskBase)</li>
<li>TaskDay            (TaskBase)</li>
<li>TaskWeek           (TaskBase)</li>
<li>TaskMonth          (TaskBase)</li>
<li>TaskRange          (TaskBase)</li>
</ol>

<p>所以这里是可以扩展更多时间类型的, 并确保在 <code>TaskBase.DateTypes</code> 里也加上。</p>

<h4>
<a id="hadoop继承类" class="anchor" href="#hadoop%E7%BB%A7%E6%89%BF%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hadoop继承类:</h4>

<ol>
<li>TaskDayHadoop      (luigi.hadoop.HadoopExt, TaskDay)</li>
<li>TaskWeekHadoop     (luigi.hadoop.HadoopExt, TaskWeek)</li>
<li>TaskRangeHadoop    (luigi.hadoop.HadoopExt, TaskRange)</li>
</ol>

<h4>
<a id="其他类" class="anchor" href="#%E5%85%B6%E4%BB%96%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他类:</h4>

<ol>
<li>RootTask           (luiti.Task)</li>
<li>StaticFile         (luiti.Task)</li>
<li>MongoImportTask    (TaskBase) # 导出 MR 结果到 mongodb 。</li>
</ol>

<h3>
<a id="时间库" class="anchor" href="#%E6%97%B6%E9%97%B4%E5%BA%93" aria-hidden="true"><span class="octicon octicon-link"></span></a>时间库</h3>

<p>采用的时间类库是 <a href="http://crsmithdev.com/arrow/">Arrow</a> , 每一个 Task
instance 具体引用的时间 instance 都是 arrow.Arrow 类型。</p>

<p>在 luiti 插件里均直接转换到本地时区。如果需要自定义时间，请优先使用
 <code>ArrowParameter.get(*strs)</code> 和 <code>ArrowParameter.now()</code> 等 以保证都
 转换到本地时区。</p>

<h2>
<a id="task-规范-和-内置属性-和-推荐做法" class="anchor" href="#task-%E8%A7%84%E8%8C%83-%E5%92%8C-%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7-%E5%92%8C-%E6%8E%A8%E8%8D%90%E5%81%9A%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>Task 规范 和 内置属性 和 推荐做法</h2>

<h3>
<a id="task-命名规范" class="anchor" href="#task-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83" aria-hidden="true"><span class="octicon octicon-link"></span></a>Task 命名规范</h3>

<ol>
<li>一个 Task 类，一个文件。</li>
<li>Task 类为驼峰方式(比如 <code>EnglishStudentAllExamWeek</code> )，文件名为
小写加下划线方式(比如 <code>english_student_all_exam_week.py</code> ) 。</li>
<li>Task 文件所位于的目录均为 <code>luiti_tasks</code>, 这样支持了 装饰器
<code>@luigi.ref_tasks(*tasks)</code> 相互惰性自动引用，也支持多项目目录
Task 引用。</li>
<li>Task 类名必须以 Day, Week 等时间类型结尾，具体参考 <code>TaskBase.DateTypes</code> 。</li>
</ol>

<h3>
<a id="task-内置属性" class="anchor" href="#task-%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a>Task 内置属性</h3>

<ol>
<li>
<code>date_value</code> 。强制参数, 即使是 Range 类型的 Task 也是需要的，这样
保证结果会 <code>output</code> 到某天的目录。另外在 <code>__init__</code> 时会被转换称
arrow.Arrow 的本地时区类型。</li>
<li>
<code>data_file</code> 。结果输出的绝对地址，字符串类型。</li>
<li>
<code>data_dir</code> 。结果输出的绝对地址目录，字符串类型。</li>
<li>
<code>root_dir</code> 。输出的根目录, <code>data_file</code> 和 <code>data_dir</code> 都是在其之下。</li>
<li>
<code>output</code> 。基本类输出到 LocalTarget , Hadoop类型会输出到 hdfs.HdfsTarget 。</li>
<li>
<code>date_str</code> 。返回 20140901 格式的时间字符串。</li>
<li>
<code>date_type</code> 。从类名中获取并返回 Day, Week 等字符串。</li>
<li>
<code>date_value_by_type_in_last</code> 。如果时间类型是 Week ，就返回上周一的
arrow.Arrow 。</li>
<li>
<code>date_value_by_type_in_begin</code> 。如果时间类型是 Week ，就返回当前周一的
零点。</li>
<li>
<code>date_value_by_type_in_end</code> 。如果时间类型是 Week ，就返回当前周日的
11:59:59。</li>
<li>
<code>pre_task_by_self</code> 。一般情况下返回当前时间类型的上个时间点的任务。
如果达到了该任务类型的时间边界，就返回 RootTask 。</li>
<li>
<code>is_reach_the_edge</code> 。在 17zuoye 的业务是学期边界。</li>
<li>
<code>instances_by_date_range</code>。类方法。返回属于某周期里的所有当前任务实例列表。</li>
<li>
<code>task_class</code>。返回当前 Task 类。</li>
</ol>

<h3>
<a id="task-推荐做法" class="anchor" href="#task-%E6%8E%A8%E8%8D%90%E5%81%9A%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>Task 推荐做法</h3>

<h4>
<a id="缓存" class="anchor" href="#%E7%BC%93%E5%AD%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>缓存</h4>

<p>强烈推荐使用 <a href="http://werkzeug.pocoo.org/">Werkzeug. The Python WSGI Utility Library</a> 实现的 <code>cached_property</code> , 是 Python 内置的 property 的缓存版本，惰性载入耗CPU和IO
资源的字典数据。示例:</p>

<div class="highlight highlight-python"><pre><span class="pl-k">class</span> <span class="pl-en">AnotherBussinessDay</span>(<span class="pl-e">TaskDayHadoop</span>):

    <span class="pl-k">def</span> <span class="pl-en">requires</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> [task1, task2, ...]

    <span class="pl-k">def</span> <span class="pl-en">mapper</span>(<span class="pl-smi">self</span>, <span class="pl-smi">line1</span>):
        k1, v1 <span class="pl-k">=</span> process(line1)
        <span class="pl-k">yield</span> k1, v1

    <span class="pl-k">def</span> <span class="pl-en">reducer</span>(<span class="pl-smi">self</span>, <span class="pl-smi">k1</span>, <span class="pl-smi">vs1</span>):
        <span class="pl-k">for</span> v1 <span class="pl-k">in</span> vs1:
            v2 <span class="pl-k">=</span> func2(v1, <span class="pl-v">self</span>.another_dict)
            <span class="pl-k">yield</span> k1, v2

    <span class="pl-en">@cached_property</span>
    <span class="pl-k">def</span> <span class="pl-en">another_dict</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># lots of cpu/io</span>
        <span class="pl-k">return</span> big_dict</pre></div>

<h4>
<a id="全局实用工具" class="anchor" href="#%E5%85%A8%E5%B1%80%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局实用工具</h4>

<ol>
<li>os, re, json, defaultdict 等基本工具。</li>
<li>arrow, ArrowParameter 时间处理工具。</li>
<li>
<code>cached_property</code>, 缓存里已介绍。</li>
<li> IOUtils, DateUtils, TargetUtils, HDFSUtils, MRUtils, MathUtils,
 CommandUtils, CompressUtils, 使用见具体实现。</li>
</ol>

<h2>
<a id="task-decorators" class="anchor" href="#task-decorators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Task decorators</h2>

<div class="highlight highlight-python"><pre><span class="pl-c"># 1. 惰性绑定相关 Task, 直接作为 instance property 使用。</span>
<span class="pl-en">@</span><span class="pl-en">luigi.ref_tasks</span>(<span class="pl-k">*</span>tasks)

<span class="pl-c"># 2. 检查当前日期是否满足Task依赖的时间区间。</span>
<span class="pl-en">@</span><span class="pl-en">luigi.check_date_range</span>()

<span class="pl-c"># 3. 检查 Task 可以运行的时间点。</span>
<span class="pl-en">@</span><span class="pl-en">luigi.check_runtime_range</span>(<span class="pl-smi">hour_num</span><span class="pl-k">=</span>[<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>], <span class="pl-smi">weekday_num</span><span class="pl-k">=</span>[<span class="pl-c1">1</span>])

<span class="pl-c"># 4. 绑定除了默认的 `date_file` 之外的输出文件名。同时兼容了任务失败时的删除处理。</span>
<span class="pl-en">@</span><span class="pl-en">luigi.persist_files</span>(<span class="pl-k">*</span>files)

<span class="pl-k">class</span> <span class="pl-en">AnotherBussinessDay</span>(<span class="pl-e">TaskDayHadoop</span>):
    <span class="pl-k">pass</span></pre></div>

<h2>
<a id="mapreduce-related" class="anchor" href="#mapreduce-related" aria-hidden="true"><span class="octicon octicon-link"></span></a>MapReduce related</h2>

<h4>
<a id="任务失败时的临时文件处理" class="anchor" href="#%E4%BB%BB%E5%8A%A1%E5%A4%B1%E8%B4%A5%E6%97%B6%E7%9A%84%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86" aria-hidden="true"><span class="octicon octicon-link"></span></a>任务失败时的临时文件处理</h4>

<p>执行 MR 时, luigi 会先输出到有时间戳的临时文件。如果任务成功，则重命名
到原先任务指定的名字。如果任务失败，则 YARN 会自动删除该临时文件。</p>

<h4>
<a id="mr-键值解析" class="anchor" href="#mr-%E9%94%AE%E5%80%BC%E8%A7%A3%E6%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>MR 键值解析</h4>

<p>luiti 推荐是 组合键 unicode 作为 Map Key, 而 dict (序列化为json格式) 作为 Reduce Value 。推荐使
用 <code>MRUtils.split_mr_kv</code>, 该函数会返回 [unicode, dict] 结果。</p>

<h4>
<a id="mr-键的组合处理" class="anchor" href="#mr-%E9%94%AE%E7%9A%84%E7%BB%84%E5%90%88%E5%A4%84%E7%90%86" aria-hidden="true"><span class="octicon octicon-link"></span></a>MR 键的组合处理</h4>

<ol>
<li>
<code>MRUtils.concat_prefix_keys(*keys)</code> 。组合多个键。</li>
<li>
<code>MRUtils.is_mr_line(line1)</code> 。判断是否是 MR 格式的行输出。</li>
<li>
<code>MRUtils.split_prefix_keys(line_part_a)</code> 。用默认分隔符 分割, 返回字符串列表。</li>
<li>
<code>MRUtils.select_prefix_keys(line_part_a, idxes=None)</code> 。用索引来取得组合键的
某些部分，并支持修复因 json 序列化带来的误操作（在首尾多了 <code>"</code> 引号）。</li>
</ol>

<h4>
<a id="mr-读入文件处理-generator-方式" class="anchor" href="#mr-%E8%AF%BB%E5%85%A5%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86-generator-%E6%96%B9%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>MR 读入文件处理, generator 方式</h4>

<ol>
<li>原始读入。 <code>TargetUtils.line_read(hdfs1)</code>。返回 unicode。</li>
<li>JSON读入。 <code>TargetUtils.json_read(hdfs1)</code>。返回 json 相关类型。</li>
<li>MR读入。   <code>TargetUtils.mr_read(hdfs1)</code>。返回 [unicode, json 相关类型] 键值对形式。</li>
</ol>

<p>示例:</p>

<div class="highlight highlight-python"><pre><span class="pl-k">for</span> k1, v1 <span class="pl-k">in</span> MRUtils.mr_read(hdfs1):
    <span class="pl-c1">isinstance</span>(k1, <span class="pl-c1">unicode</span>)
    <span class="pl-c1">isinstance</span>(v1, <span class="pl-c1">dict</span>)</pre></div>

<h4>
<a id="hdfs-文件对象" class="anchor" href="#hdfs-%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1" aria-hidden="true"><span class="octicon octicon-link"></span></a>HDFS 文件对象</h4>

<p>使用 <code>TargetUtils.hdfs(path1)</code> 。该函数同时兼容了 MR 按 <code>part-00000</code>
分文件块的数据格式。</p>

<h4>
<a id="mr-test" class="anchor" href="#mr-test" aria-hidden="true"><span class="octicon octicon-link"></span></a>MR test</h4>

<ol>
<li>给继承 Hadoop 相关Task基类 的 具体业务 Task 加上 <code>mrtest_input</code> 和
<code>mrtest_output</code> 两个方法，分别用于 MR 的文本输入和输出。</li>
<li>在测试代码里加上如下代码，luiti 就会自动给 <code>mr_task_names</code> 里的所有 Task
生成测试用例，然后按正常方式跑 Python 测试用例即可。</li>
<li>还可以用 <code>mrtest_attrs</code> 生成该实例上的多个字典属性。</li>
</ol>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> luiti <span class="pl-k">import</span> MrTestCase

<span class="pl-en">@MrTestCase</span>
<span class="pl-k">class</span> <span class="pl-en">TestMapReduce</span>(<span class="pl-e">unittest.TestCase</span>):
    mr_task_names <span class="pl-k">=</span> [
            <span class="pl-s"><span class="pl-pds">'</span>ClassEnglishAllExamWeek<span class="pl-pds">'</span></span>,
            ...
           ]

<span class="pl-k">if</span> <span class="pl-c1">__name__</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>__main__<span class="pl-pds">'</span></span>: unittest.main()</pre></div>

<h2>
<a id="manage-multiple-projects-in-luiti" class="anchor" href="#manage-multiple-projects-in-luiti" aria-hidden="true"><span class="octicon octicon-link"></span></a>Manage multiple projects in luiti</h2>

<h4>
<a id="具体单个项目的目录结构" class="anchor" href="#%E5%85%B7%E4%BD%93%E5%8D%95%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>具体单个项目的目录结构</h4>

<p>每个项目目录结构建议为以下格式，即可以当作一个正规的 Python package 来使用， 比如:</p>

<pre lang="text"><code>project_A                                            --- project directory
  setup.py                                           --- Python package install script
  README.markdown                                    --- project README
  project_A/                                         --- Python package install directory
  ├── __init__.py                                    --- mark current directories on disk as a Python package directories
  └── luiti_tasks                                    --- a directory name which indicates it contains several luiti tasks
      ├── __init__.py                                --- mark current directories on disk as a Python package directories
      ├── __init_luiti.py                            --- initialize luiti environment variables
      ├── exam_logs_english_app_day.py               --- an example luiti task
      ├── ..._day.py                                 --- another example luiti task
      └── templates                                  --- some libraries
            ├── __init__.py
            └── ..._template.py
</code></pre>

<p>在安装好 <code>luiti</code> 后，运行如下命令行即可生成上述的项目基本目录结构，</p>

<div class="highlight highlight-bash"><pre>luiti new project_A</pre></div>

<p>这个树目录其实就是可以用来安装 package 的 Python 项目, 在根的 <code>project_A</code> 目录
下运行 <code>python setup.py install</code> 即可把当前项目安装到当前 Python 环境的 package
引用路径(即 <code>sys.path</code> )下。</p>

<h4>
<a id="如何关联另一个项目的某个-task" class="anchor" href="#%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9F%90%E4%B8%AA-task" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何关联另一个项目的某个 Task</h4>

<p>每个项目都是类似 <code>project_A/luiti_tasks/another_feature_day.py</code> 结构，在 <code>__init_luiti.py</code> 只要
用 <code>luigi.plug_packages("project_B", "project_C==0.0.2"])</code> 后， 像 <code>@luigi.ref_tasks("ArtistStreamDay')</code>
就会现在当前 <code>project_A</code>, 和相关的 <code>project_B</code>, <code>project_C</code> 里去找 ArtistStreamDay Task 了。</p>

<h2>
<a id="extend-luiti" class="anchor" href="#extend-luiti" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extend luiti</h2>

<p>使用 TaskBase 里自带 extend 类方法扩展或者覆写默认属性或方法，比如:</p>

<div class="highlight highlight-python"><pre>TaskWeek.extend({
    <span class="pl-s"><span class="pl-pds">'</span>property_1<span class="pl-pds">'</span></span> : <span class="pl-k">lambda</span> <span class="pl-smi">self</span>: <span class="pl-s"><span class="pl-pds">"</span>property_2<span class="pl-pds">"</span></span>,
})</pre></div>

<p><code>extend</code> 类方法同时兼容了 <code>function</code>, <code>property</code>, <code>cached_property</code>,
或者其他任意类属性。在覆写 <code>property</code> 和 <code>cached_property</code>
传一个函数值即可，<code>extend</code> 会自动转化为本来的 <code>property</code> 和
<code>cached_property</code> 类型。</p>

<h2>
<a id="faq" class="anchor" href="#faq" aria-hidden="true"><span class="octicon octicon-link"></span></a>FAQ</h2>

<p>Q: How atomic file is supported?</p>

<p>A: As luigi's document mentioned that "Simple class that writes to a temp file and moves it on close()
    Also cleans up the temp file if close is not invoked", so use the <code>self.input().open("r")</code> or
    <code>self.output().open("w")</code> instead of <code>open("some_file", "w")</code>.</p>

<p>Q: Can luigi detect the interdependent tasks?</p>

<p>A: It's not question inside of luigi, but it's a question about <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sorting</a>
   as a general computer science topic. The task scheduler is implemented at <code>luigi/scheduler.py</code> .</p>

<p>If you have other unresolved questions, please feel free to ask
questions at <a href="https://github.com/17zuoye/luiti/issues">issues</a>.</p>

<h2>
<a id="run-tests" class="anchor" href="#run-tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run tests</h2>

<div class="highlight highlight-bash"><pre>./tests/run.sh</pre></div>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>MIT. David Chen @ 17zuoye.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/17zuoye/luiti">Luiti</a> is maintained by <a href="https://github.com/17zuoye">17zuoye</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-57207964-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>

